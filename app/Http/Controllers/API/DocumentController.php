<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use PhpOffice\PhpWord\PhpWord;
use PhpOffice\PhpWord\IOFactory;
use Barryvdh\DomPDF\Facade\Pdf;
use SimpleSoftwareIO\QrCode\Facades\QrCode;
use App\Models\Conversation;
use App\Models\ChatMessage;
use GuzzleHttp\Client;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Auth;
use App\Models\UserSignature;
use Illuminate\Support\Str;

class DocumentController extends Controller
{
    /**
     * Generate a Word document.
     */
    public function generateWord($conversationId)
{
    $conversation = $this->getConversation($conversationId);
    $chatbotResponse = $this->generateDocumentFromChatbot($conversationId);

    if (!$chatbotResponse) {
        Log::error("AI did not return a response for Word document.");
        return response()->json(['error' => 'Failed to generate Word document.'], 500);
    }

    // Ukloni oznake za bold
    $chatbotResponse = preg_replace('/\*\*(.*?)\*\*/', '$1', $chatbotResponse);

    // Sekcije ovisno o tipu dokumenta
    $sections = match ($conversation->document_type) {
        'tužba' => ['Činjenični opis', 'Pravni temelj', 'Zahtjev'],
        'ugovor' => ['Predmet ugovora', 'Obveze stranaka', 'Trajanje i raskid'],
        'punomoć' => ['Opunomoćenik', 'Opunomoćitelj', 'Sadržaj punomoći'],
        default => ['Opći podaci', 'Sadržaj', 'Zaključak'],
    };

    // Ekstrahiraj podatke iz AI odgovora
    $caseDescription = $this->extractSection($chatbotResponse, 'Činjenični opis') ?? $this->getFallbackCaseDescription($conversationId);
    $legalBasis = $this->extractSection($chatbotResponse, 'Pravni temelj') ?? $this->getFallbackLegalBasis($conversationId);
    $claim = $this->extractSection($chatbotResponse, 'Zahtjev') ?? $this->getFallbackClaim($conversationId);

    // Kreiraj Word dokument
    $phpWord = new PhpWord();
    $section = $phpWord->addSection();

    // Naslov
    $section->addText("LEGAL DOCUMENT", ['bold' => true, 'size' => 16], ['alignment' => 'center']);
    $section->addText("Generated by AI Lawyer", ['bold' => true, 'italic' => true, 'size' => 12]);
    $section->addTextBreak(2);
    $section->addText("Topic: " . $conversation->topic, ['bold' => true, 'size' => 12]);
    $section->addText("Generated on: " . date('d.m.Y'), ['italic' => true, 'size' => 10]);
    $section->addTextBreak(2);

    // Dodaj sekcije strukturirano
    $section->addText("Činjenični opis:", ['bold' => true, 'size' => 12]);
    $section->addText($caseDescription, ['size' => 12]);
    $section->addTextBreak(1);

    $section->addText("Pravni temelj:", ['bold' => true, 'size' => 12]);
    $section->addText($legalBasis, ['size' => 12]);
    $section->addTextBreak(1);

    $section->addText("Zahtjev:", ['bold' => true, 'size' => 12]);
    if (is_array($claim)) {
        foreach ($claim as $item) {
            $section->addListItem($item, 0, ['size' => 12]);
        }
    } else {
        $section->addText($claim, ['size' => 12]);
    }

    $this->ensureDirectoryExists(storage_path('app/public/documents'));
    $filePath = storage_path("app/public/documents/Legal_Document_{$conversationId}.docx");
    $writer = IOFactory::createWriter($phpWord, 'Word2007');
    $writer->save($filePath);

    return response()->json([
        'message' => 'Word document generated successfully.',
        'file_url' => asset("storage/documents/Legal_Document_{$conversationId}.docx")
    ]);
}


    /**
     * Generate a signed PDF with a QR code and (if available) the user signature.
     */
    public function generateSignedPdf(Request $request, $conversationId)
    {
        $conversation = $this->getConversation($conversationId);
        $chatbotResponse = $this->generateDocumentFromChatbot($conversationId);

        if (!$chatbotResponse) {
            Log::error("AI did not return a response for PDF generation.");
            return response()->json(['error' => 'Failed to generate PDF.'], 500);
        }

        // Remove bold markers from AI response
        $chatbotResponse = preg_replace('/\*\*(.*?)\*\*/', '$1', $chatbotResponse);
        Log::info("AI response for PDF: " . $chatbotResponse);

        // Determine document sections (you can adjust these as needed)
        $sections = match ($conversation->document_type) {
            'tužba' => ['Činjenični opis', 'Pravni temelj', 'Zahtjev'],
            'ugovor' => ['Predmet ugovora', 'Obveze stranaka', 'Trajanje i raskid'],
            'punomoć' => ['Opunomoćenik', 'Opunomoćitelj', 'Sadržaj punomoći'],
            default => ['Opći podaci', 'Sadržaj', 'Zaključak'],
        };

        // Extract data from AI response with fallbacks
        $caseDescription = $this->extractSection($chatbotResponse, 'Činjenični opis') ?? $this->getFallbackCaseDescription($conversationId);
        $legalBasis = $this->extractSection($chatbotResponse, 'Pravni temelj') ?? $this->getFallbackLegalBasis($conversationId);
        $claim = $this->extractSection($chatbotResponse, 'Zahtjev') ?? $this->getFallbackClaim($conversationId);

        // Process the user signature:
        $signatureData = UserSignature::where('user_id', Auth::id())->value('signature');
        if ($signatureData) {
            // If the signature is not already a data URI, try to load it from the local file system.
            if (!Str::startsWith($signatureData, 'data:image')) {
                $localPath = public_path(ltrim($signatureData, '/'));
                if (file_exists($localPath)) {
                    $fileContents = file_get_contents($localPath);
                    $signatureData = "data:image/png;base64," . base64_encode($fileContents);
                }
            }
        }

        // Generate QR code for verification
        $verificationUrl = url("/api/verify-document/{$conversationId}");
        $qrCode = base64_encode(QrCode::format('png')->size(200)->generate($verificationUrl));

        $pdfPath = storage_path("app/public/documents/Legal_Document_{$conversationId}.pdf");

        // Prepare data for the PDF view
        $data = [
            'Naslov dokumenta' => ucfirst($conversation->document_type ?? 'Pravni dokument'),
            'Tema' => $conversation->topic ?? 'N/A',
            'Činjenični opis' => $caseDescription,
            'Pravni temelj' => $legalBasis,
            'Zahtjev' => is_array($claim) ? implode("\n", $claim) : $claim
        ];

        $pdf = Pdf::loadView('pdf.legal_document', [
            'conversation' => $conversation,
            'qrCode' => $qrCode,
            'verificationUrl' => $verificationUrl,
            'signatureData' => $signatureData,
            'data' => $data
        ])->setPaper('A4', 'portrait')->setOptions([
            'defaultFont' => 'DejaVu Sans',
            'isHtml5ParserEnabled' => true,
            'isRemoteEnabled' => true
        ]);

        $pdf->save($pdfPath);

        return response()->json([
            'message' => 'Signed PDF generated successfully.',
            'file_url' => asset("storage/documents/Legal_Document_{$conversationId}.pdf")
        ]);
    }

    /**
     * Fetch conversation data for the authenticated user.
     */
    private function getConversation($conversationId)
    {
        return Conversation::where('id', $conversationId)
            ->where('user_id', auth()->id())
            ->firstOrFail();
    }

    /**
     * Retrieve AI-generated content for the document.
     */
    public function generateDocumentFromChatbot($conversationId)
    {
        $conversation = $this->getConversation($conversationId);

        $messages = ChatMessage::where('conversation_id', $conversationId)
            ->orderBy('created_at')
            ->get()
            ->map(fn ($msg) => ['role' => $msg->role, 'content' => $msg->message])
            ->toArray();

            $instructions = match ($conversation->document_type) {
                'tužba' => 'Generiraj pravni dokument u obliku tužbe. Jasno odvoji sekcije: "Činjenični opis", "Pravni temelj" i "Zahtjev". Svaka sekcija mora imati jedinstven sadržaj. Nemoj ponavljati tekst između sekcija. Koristi jasan format: naziv sekcije, pa novi red, pa sadržaj.',
                'ugovor' => 'Generiraj pravni dokument u obliku kupoprodajnog ugovora. Jasno označi sekcije kao "Predmet ugovora", "Obveze stranaka", "Trajanje i raskid". Svaka sekcija mora imati različit sadržaj i jasan naslov u tekstu.',
                default => 'Generiraj pravni dokument s jasno označenim sekcijama. Svaka sekcija mora imati različit sadržaj i vlastiti naslov.',
            };

        array_unshift($messages, ['role' => 'system', 'content' => $instructions]);

        try {
            $client = new Client();
            $response = $client->post('https://api.openai.com/v1/chat/completions', [
                'headers' => [
                    'Authorization' => 'Bearer ' . env('OPENAI_API_KEY'),
                    'Content-Type' => 'application/json'
                ],
                'json' => [
                    'model' => 'ft:gpt-4o-2024-08-06:toplaw:toplaw:AtYaitAD',
                    'messages' => $messages,
                    'max_tokens' => 1000,
                    'temperature' => 0.3
                ]
            ]);

            return json_decode($response->getBody(), true)['choices'][0]['message']['content'] ?? null;
        } catch (\Exception $e) {
            Log::error("Error retrieving AI response: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Extract a section from the AI-generated text.
     */
    private function extractSection($text, $sectionTitle)
    {
        $pattern = '/'.preg_quote($sectionTitle, '/').'\s*[:\n](.*?)(?=\n(?:Činjenični opis|Pravni temelj|Zahtjev|Predmet ugovora|Obveze stranaka|Trajanje i raskid|Opunomoćenik|Opunomoćitelj|Sadržaj punomoći|Opći podaci|Sadržaj|Zaključak)\s*[:\n]|\z)/si';

        preg_match($pattern, $text, $matches);
        return isset($matches[1]) ? trim($matches[1]) : null;
    }

    /**
     * Fallback for legal basis if not returned by AI.
     */
    private function getFallbackLegalBasis($conversationId)
    {
        return ChatMessage::where('conversation_id', $conversationId)
            ->where('role', 'user')
            ->where('message', 'LIKE', '%zakon%')
            ->orderBy('created_at', 'desc')
            ->value('message') ?? "Legal basis not properly retrieved.";
    }

    /**
     * Fallback for claim if not returned by AI.
     */
    private function getFallbackClaim($conversationId)
    {
        return ChatMessage::where('conversation_id', $conversationId)
            ->where('role', 'user')
            ->where('message', 'LIKE', '%naknada%')
            ->orderBy('created_at', 'desc')
            ->value('message') ?? "Claim not properly generated.";
    }

    /**
     * Fallback for case description if not returned by AI.
     */
    private function getFallbackCaseDescription($conversationId)
    {
        return ChatMessage::where('conversation_id', $conversationId)
            ->where('role', 'user')
            ->orderBy('created_at', 'desc')
            ->value('message') ?? "Case description not properly generated.";
    }

    /**
     * Ensure that the specified directory exists.
     */
    private function ensureDirectoryExists($path)
    {
        if (!file_exists($path)) {
            mkdir($path, 0775, true);
        }
    }

    /**
     * Save the user's signature for document signing.
     */
    public function saveSignature(Request $request)
    {
        $request->validate([
            'signature' => 'required|string',
        ]);

        $userId = Auth::id();
        $signature = $request->input('signature');

        // Check if the signature is in Base64 format and save it as an image file.
        if (Str::startsWith($signature, 'data:image')) {
            $image = str_replace('data:image/png;base64,', '', $signature);
            $image = str_replace(' ', '+', $image);
            $imageName = "signatures/user_{$userId}_" . time() . ".png";

            Storage::disk('public')->put($imageName, base64_decode($image));

            $signature = "/storage/{$imageName}";
        }

        UserSignature::updateOrCreate(
            ['user_id' => $userId],
            ['signature' => $signature]
        );

        return response()->json([
            'message' => 'Signature saved successfully!',
            'signature_path' => $signature
        ]);
    }
}
